module.exports={name:"@yarnpkg/plugin-prebuilds",factory:function(e){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=6)}([function(t,r){t.exports=e("@yarnpkg/core")},function(t,r){t.exports=e("@yarnpkg/fslib")},function(t,r){t.exports=e("@yarnpkg/libzip")},function(t,r){t.exports=e("@yarnpkg/plugin-npm")},function(e,t,r){var n=r(5);function i(e,t){null==t&&(t=u);var r=t.filter((function(t){return t.runtime===e})).slice(-1)[0],i="electron"===e?"minor":"major";return n.inc(r.target,i)}var a=[{runtime:"node",target:"5.0.0",abi:"47",lts:!1},{runtime:"node",target:"6.0.0",abi:"48",lts:!1},{runtime:"node",target:"7.0.0",abi:"51",lts:!1},{runtime:"node",target:"8.0.0",abi:"57",lts:!1},{runtime:"node",target:"9.0.0",abi:"59",lts:!1},{runtime:"node",target:"10.0.0",abi:"64",lts:new Date(2018,10,1)<new Date&&new Date<new Date(2020,4,31)},{runtime:"node",target:"11.0.0",abi:"67",lts:!1},{runtime:"node",target:"12.0.0",abi:"72",lts:new Date(2019,9,21)<new Date&&new Date<new Date(2020,9,31)},{runtime:"node",target:"13.0.0",abi:"79",lts:!1},{runtime:"node",target:"14.0.0",abi:"83",lts:!1},{runtime:"electron",target:"0.36.0",abi:"47",lts:!1},{runtime:"electron",target:"1.1.0",abi:"48",lts:!1},{runtime:"electron",target:"1.3.0",abi:"49",lts:!1},{runtime:"electron",target:"1.4.0",abi:"50",lts:!1},{runtime:"electron",target:"1.5.0",abi:"51",lts:!1},{runtime:"electron",target:"1.6.0",abi:"53",lts:!1},{runtime:"electron",target:"1.7.0",abi:"54",lts:!1},{runtime:"electron",target:"1.8.0",abi:"57",lts:!1},{runtime:"electron",target:"2.0.0",abi:"57",lts:!1},{runtime:"electron",target:"3.0.0",abi:"64",lts:!1},{runtime:"electron",target:"4.0.0",abi:"64",lts:!1},{runtime:"electron",target:"4.0.4",abi:"69",lts:!1},{runtime:"electron",target:"5.0.0",abi:"70",lts:!1},{runtime:"electron",target:"6.0.0",abi:"73",lts:!1},{runtime:"electron",target:"7.0.0",abi:"75",lts:!1},{runtime:"electron",target:"8.0.0",abi:"76",lts:!1},{runtime:"electron",target:"9.0.0",abi:"80",lts:!1}],o=[{runtime:"node-webkit",target:"0.13.0",abi:"47",lts:!1},{runtime:"node-webkit",target:"0.15.0",abi:"48",lts:!1},{runtime:"node-webkit",target:"0.18.3",abi:"51",lts:!1},{runtime:"node-webkit",target:"0.23.0",abi:"57",lts:!1},{runtime:"node-webkit",target:"0.26.5",abi:"59",lts:!1}],s=[{runtime:"node",target:"0.2.0",abi:"1",lts:!1},{runtime:"node",target:"0.9.1",abi:"0x000A",lts:!1},{runtime:"node",target:"0.9.9",abi:"0x000B",lts:!1},{runtime:"node",target:"0.10.4",abi:"11",lts:!1},{runtime:"node",target:"0.11.0",abi:"0x000C",lts:!1},{runtime:"node",target:"0.11.8",abi:"13",lts:!1},{runtime:"node",target:"0.11.11",abi:"14",lts:!1},{runtime:"node",target:"1.0.0",abi:"42",lts:!1},{runtime:"node",target:"1.1.0",abi:"43",lts:!1},{runtime:"node",target:"2.0.0",abi:"44",lts:!1},{runtime:"node",target:"3.0.0",abi:"45",lts:!1},{runtime:"node",target:"4.0.0",abi:"46",lts:!1},{runtime:"electron",target:"0.30.0",abi:"44",lts:!1},{runtime:"electron",target:"0.31.0",abi:"45",lts:!1},{runtime:"electron",target:"0.33.0",abi:"46",lts:!1}],l=[{runtime:"electron",target:"10.0.0-beta.1",abi:"82",lts:!1}],u=s.concat(a).concat(o).concat(l);t.getAbi=function(e,t){if(e===String(Number(e)))return e;if(e&&(e=e.replace(/^v/,"")),t||(t="node"),"node"===t){if(!e)return process.versions.modules;if(e===process.versions.node)return process.versions.modules}for(var r,a=0;a<u.length;a++){var o=u[a];if(o.runtime===t){if(!n.lte(o.target,e))break;r=o.abi}}if(r&&n.lt(e,i(t)))return r;throw new Error("Could not detect abi for version "+e+" and runtime "+t+'.  Updating "node-abi" might help solve this issue if it is a new release of '+t)},t.getTarget=function(e,t){if(e&&e!==String(Number(e)))return e;if(t||(t="node"),"node"===t&&!e)return process.versions.node;var r=u.filter((function(r){return r.abi===e&&r.runtime===t})).map((function(e){return e.target}));if(r.length)return r[0];throw new Error("Could not detect target for abi "+e+" and runtime "+t)},t.deprecatedTargets=s,t.supportedTargets=a,t.additionalTargets=o,t.futureTargets=l,t.allTargets=u,t._getNextTarget=i},function(t,r){t.exports=e("semver")},function(e,t,r){"use strict";r.r(t);var n=r(0);var i=r(1),a=r(2),o=r(3),s=r(4);const l=async e=>{for(const t of e.storedPackages.values())if("electron"===t.name)return t.version;return null},u=async(e,t,r)=>{for(const r of e.storedPackages.values())if(r.name===t.name&&r.scope===t.scope)return r;return null};function c(e,t,r){const n=r.project.configuration,i=`@${e.scope}`,a=(e.scope?function(e,t){const r=t.get("prebuildScopes").get(e);return void 0!==r?r:null}(i,n):null)||n;return a.get(t)?a.get(t):n.get(t)}function p(e){return Object(s.getAbi)(e,"electron")}async function d(e,t,r){const i=n.structUtils.stringifyIdent(e).replace(/^@\w+\//,""),a=e.version,s=r.abi,l=r.runtime,u=process.platform,p=process.arch,d=process.env.LIBC||"",g=c(e,"prebuildTagPrefix",t),f=`${i}-v${a}-${l}-v${s}-${u}${d}-${p}.tar.gz`,m=c(e,"prebuildHostMirrorUrl",t);if(m){return function(e,t){for(const[r,n]of Object.entries(t))e=e.replace(new RegExp(`{${r}}`,"g"),n);return e}(c(e,"prebuildHostMirrorTemplate",t),{mirror_url:m,name:i,version:a,abi:s,runtime:l,platform:u,arch:p,libc:d,tag_prefix:g,scope:e.scope||"",scopeWithAt:e.scope?`@${e.scope}`:"",scopeWithAtAndSlash:e.scope?`@${e.scope}/`:"",scopeWithSlash:e.scope?`${e.scope}/`:""})}return`${await async function(e,t){var r;const i=await o.npmHttpUtils.get(o.npmHttpUtils.getIdentUrl(e),{configuration:t.project.configuration,ident:e,json:!0});if(!Object.prototype.hasOwnProperty.call(i,"versions"))throw new n.ReportError(n.MessageName.REMOTE_INVALID,'Registry returned invalid data for - missing "versions" field');if(!Object.prototype.hasOwnProperty.call(i.versions,e.version))throw new n.ReportError(n.MessageName.REMOTE_NOT_FOUND,`Registry failed to return reference "${e.version}"`);const a=null===(r=i.versions[e.version].repository)||void 0===r?void 0:r.url;if(!a)throw new n.ReportError(n.MessageName.UNNAMED,`Unable to find repository information for "${n.structUtils.stringifyIdent(e)}"`);const s=function(e){var t=/github\.com\/([^\/]+)\/([^\/\.]+)\.git/.exec(e);return t?`https://github.com/${t[1]}/${t[2]}`:null}(a);if(!s)throw new n.ReportError(n.MessageName.UNNAMED,`Unable to find GitHub URL for "${n.structUtils.stringifyIdent(e)}"`);return s}(e,t)}/releases/download/${g}${a}/${f}`}const g=async(e,t,r,n)=>{if(n.cancel)return;const a=await e.readdirPromise(t);await Promise.all(a.map(async a=>{if(n.cancel)return;const o=i.ppath.join(t,a),s=await e.statPromise(o);s.isDirectory()?await g(e,o,r,n):s.isFile()&&await r(e,o)}))};const f={prebuildRuntime:{description:"The runtime used, either 'electron' or 'node'",type:n.SettingsType.STRING,default:null},prebuildAbi:{description:"The ABI of the runtime used.",type:n.SettingsType.STRING,default:null},prebuildTagPrefix:{description:"The prebuild tag prefix",type:n.SettingsType.STRING,default:"v"},prebuildHostMirrorUrl:{description:"The prebuild host mirror URL",type:n.SettingsType.STRING,default:null},prebuildHostMirrorTemplate:{description:"The prebuild host mirror template",type:n.SettingsType.STRING,default:"{mirror_url}/{tag_prefix}{version}/{name}-v{version}-{runtime}-v{abi}-{platform}{libc}-{arch}.tar.gz"}},m={hooks:{reduceDependency:async(e,t,r)=>{if("fsevents"===r.name&&"darwin"!==process.platform)return e;if("bindings"===e.name&&null===e.scope){const t=`builtin<prebuild/${n.structUtils.stringifyIdent(r)}>`;return n.structUtils.makeDescriptor(e,n.structUtils.makeRange({protocol:"prebuild:",source:`bindings<${n.structUtils.slugifyIdent(r)}>${process.platform}-${process.arch}`,selector:t,params:null}))}return e}},fetchers:[class{supports(e,t){return!!e.reference.startsWith("prebuild:")}getLocalPath(e,t){return null}async fetch(e,t){const r=new i.NodeFS,o=await this.fetchPrebuild(e,t),s=o.getRealPath();o.saveAndClose(),await i.xfs.chmodPromise(s,420);const l=`${t.cache.cacheKey}/${await n.hashUtils.checksumFile(s)}`,u=t.cache.getLocatorPath(e,l);if(!u)throw new Error("Assertion failed: Expected the cache path to be available");await i.xfs.movePromise(s,u),await i.xfs.mkdirpPromise(i.ppath.dirname(u));let c=null;const p=await Object(a.getLibzipPromise)();return{packageFs:new i.LazyFS(()=>n.miscUtils.prettifySyncErrors(()=>c=new i.ZipFS(u,{baseFs:r,libzip:p,readOnly:!0}),r=>`Failed to open the cache entry for ${n.structUtils.prettyLocator(t.project.configuration,e)}: ${r}`),i.ppath),releaseFs:()=>{null!==c&&c.discardAndClose()},prefixPath:n.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(e,t),checksum:l}}async fetchPrebuild(e,t){const{packageIdent:r}=function(e){const t=e.substring(e.indexOf("builtin<prebuild/")+17,e.length-1);return{packageIdent:n.structUtils.parseIdent(t)}}(e.reference),o=await l(t.project),s=await u(t.project,r,e);if(null===s)throw new n.ReportError(n.MessageName.UNNAMED,"Could not find the native module that had a prebuild attempt");if(null===s.version)throw new n.ReportError(n.MessageName.UNNAMED,"Could not find the native module version that had a prebuild attempt");const c={abi:o?p(o):process.versions.modules,runtime:o?"electron":"node"},f=await d(s,t,c);let m;try{m=await t.fetcher.fetch(n.structUtils.makeLocator(n.structUtils.makeIdent("prebuilds",`${n.structUtils.slugifyIdent(s)}-v${s.version}-${process.platform}-${process.arch}-${c.runtime}-${c.abi}`),f),t)}catch(e){throw t.report.reportInfo(n.MessageName.UNNAMED,`Error fetching ${f}`),e}const b={cancel:!1};let h=null,w="";if(await n.miscUtils.releaseAfterUseAsync(async()=>{await g(m.packageFs,".",async(e,t)=>{h=await e.readFilePromise(t),w=t,b.cancel=!0},b)},m.releaseFs),null===h)throw new n.ReportError(n.MessageName.UNNAMED,`Was unable to find node file in prebuild package for "${n.structUtils.stringifyIdent(s)}"`);const y=await i.xfs.mktempPromise(),v=i.ppath.join(y,"prebuilt.zip"),P=n.structUtils.getIdentVendorPath(e),U=await Object(a.getLibzipPromise)(),$=new i.ZipFS(v,{libzip:U,create:!0});await $.mkdirpPromise(P);const T=new i.CwdFS(P,{baseFs:$});await T.writeJsonPromise("package.json",{name:n.structUtils.slugifyLocator(e),main:"./index.js"});const k=`// Automatically generated bindings file\n// Bindings taken from ${w}\n\nconst staticRequire = require("./bindings.node");\nmodule.exports = (fileLookingFor) => {\n  return staticRequire;\n};\n    `;return await T.writeFilePromise("index.js",k),await T.writeFilePromise("bindings.node",h),$}}],resolvers:[class{supportsDescriptor(e,t){return!!e.range.startsWith("prebuild:")}supportsLocator(e,t){return!!e.reference.startsWith("prebuild:")}shouldPersistResolution(e,t){return!1}bindDescriptor(e,t,r){return e}getResolutionDependencies(e,t){return[]}async getCandidates(e,t,r){if(!r.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");return[n.structUtils.makeLocator(n.structUtils.parseIdent("bindings"),e.range)]}async resolve(e,t){return{...e,version:"*",languageName:t.project.configuration.get("defaultLanguageName"),linkType:n.LinkType.HARD,dependencies:new Map,peerDependencies:new Map,dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:new Map}}}],configuration:{...f,prebuildScopes:{description:"Prebuild settings per package scope",type:n.SettingsType.MAP,valueDefinition:{description:"",type:n.SettingsType.SHAPE,properties:{...f}}}}};t.default=m}])}};